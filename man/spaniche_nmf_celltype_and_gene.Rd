% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spaniche_nmf_celltype_and_gene.R
\name{spaniche_nmf_celltype_and_gene}
\alias{spaniche_nmf_celltype_and_gene}
\title{spaniche_nmf_celltype_and_gene: Joint factorization of cell-type abundance  and gene expression matrices}
\usage{
spaniche_nmf_celltype_and_gene(
  spatial.seu,
  spatialdf,
  spot_by_celltype,
  smoothing_type = c("view0", "view1", "view2"),
  distance_thre = c(NA, 2/(3^0.5), 4/(3^0.5)),
  digits = 2,
  ngenes = 2000,
  topic_num = 15,
  defined_weight = "default",
  lambda_v = c(0.5, 1, 2),
  sigma_v = c(0.5, 1, 1.5),
  maxiter = 200,
  st.count = 20,
  epsilon = 1e-04
)
}
\arguments{
\item{spatial.seu}{A Seurat object containing spatial transcriptomics data.
The order of spots must be consistent with spatialdf.}

\item{spatialdf}{A data frame or matrix with two columns: \code{col} and
\code{row}, representing spatial coordinates of spots. Row names must be
spot barcodes and consistent with \code{spot_by_celltype}.}

\item{spot_by_celltype}{A numeric matrix or data frame with spots as rows
and cell types as columns, representing cell type abundance or proportion.
Row names must match those of \code{spatialdf}.}

\item{smoothing_type}{Character vector specifying the spatial smoothing
levels to include. Supported values are:
\itemize{
\item \code{"view0"}: no smoothing (original matrix)
\item \code{"view1"}: first-order spatial neighbors
\item \code{"view2"}: second-order spatial neighbors
}
Valid combinations are \code{c("view0")},
\code{c("view0","view1")}, and
\code{c("view0","view1","view2")}.}

\item{distance_thre}{This parameter represents distance, defining the central distance from center to loop1 (view1), and from center to loop2 (view2). For view0, the distance is ignored and should be set to NA. The length of the vector is consistent with the smoothing_type parameter. For example, A typical choice for Visium data is: distance_thre = c(NA,round(2/(3^0.5),2),round(4/(3^0.5),2)).}

\item{digits}{integer indicating the number of decimal places.
Parameters related to gene expression.
In practice, genes may need to be pre-selected (e.g., highly variable genes).}

\item{ngenes}{The number of highly variable genes.
Parameters related to joint matrix factorization.}

\item{topic_num}{An integer specifying the number of components or topics to be extracted. It determines the number of columns in the W matrix and the number of rows in each H matrix.}

\item{defined_weight}{Either \code{"default"} to use data-driven modality
weights, or a numeric vector of length two specifying user-defined weights
for the cell-type and gene expression matrices.}

\item{lambda_v}{Vector of spatial regularization parameters controlling the
strength of Laplacian smoothness.}

\item{sigma_v}{Gaussian kernel parameter. Used in the computation of the Laplacian matrix, influencing how spatial information is incorporated into the factorization.}

\item{maxiter}{The maximum number of iterations allowed for the factorization process. This acts as a stopping criterion to prevent the algorithm from running indefinitely.}

\item{st.count}{Convergence counter. If the change in the reconstruction error remains below epsilon for st.count consecutive iterations, the algorithm stops, assuming it has converged.}

\item{epsilon}{Threshold on the relative change in the objective function used to assess convergence. If the relative change in error is less than epsilon for st.count consecutive iterations, convergence is assumed.}
}
\value{
A list containing:
\itemize{
\item \code{nmf_res}: Results from spatially regularized integrative NMF,
including factor matrices, convergence diagnostics, and cluster assignments.
}
}
\description{
This function performs spatially regularized integrative non-negative
matrix factorization by jointly decomposing a spot-by-cell-type
abundance matrix and a spot-by-gene expression matrix.
}
\details{
Spatial neighborhood information is incorporated by constructing
multi-view representations (view0, view1, view2) based on spot coordinates,
followed by graph-regularized joint matrix factorization.

The following parameters define the basic inputs of the analysis.
}
